

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pypulseq.Sequence.sequence &mdash; BMCTool</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=16f952a1" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BMCTool
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">Guide for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributor_guide.html">Guide for Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BMCTool</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pypulseq.Sequence.sequence</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pypulseq.Sequence.sequence</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
    <span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Self&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Sequence&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">PPoly</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">pypulseq</span> <span class="kn">import</span> <span class="n">eps</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence</span> <span class="kn">import</span> <span class="n">block</span><span class="p">,</span> <span class="n">parula</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence.ext_test_report</span> <span class="kn">import</span> <span class="n">ext_test_report</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence.read_seq</span> <span class="kn">import</span> <span class="n">read</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence.write_seq</span> <span class="kn">import</span> <span class="n">write</span> <span class="k">as</span> <span class="n">write_seq</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence.calc_pns</span> <span class="kn">import</span> <span class="n">calc_pns</span>
<span class="kn">from</span> <span class="nn">pypulseq.Sequence.calc_grad_spectrum</span> <span class="kn">import</span> <span class="n">calculate_gradient_spectrum</span>

<span class="kn">from</span> <span class="nn">pypulseq.calc_rf_center</span> <span class="kn">import</span> <span class="n">calc_rf_center</span>
<span class="kn">from</span> <span class="nn">pypulseq.check_timing</span> <span class="kn">import</span> <span class="n">check_timing</span> <span class="k">as</span> <span class="n">ext_check_timing</span>
<span class="kn">from</span> <span class="nn">pypulseq.decompress_shape</span> <span class="kn">import</span> <span class="n">decompress_shape</span>
<span class="kn">from</span> <span class="nn">pypulseq.event_lib</span> <span class="kn">import</span> <span class="n">EventLibrary</span>
<span class="kn">from</span> <span class="nn">pypulseq.opts</span> <span class="kn">import</span> <span class="n">Opts</span>
<span class="kn">from</span> <span class="nn">pypulseq.supported_labels_rf_use</span> <span class="kn">import</span> <span class="n">get_supported_labels</span>
<span class="kn">from</span> <span class="nn">pypulseq.utils.cumsum</span> <span class="kn">import</span> <span class="n">cumsum</span>
<span class="kn">from</span> <span class="nn">pypulseq.block_to_events</span> <span class="kn">import</span> <span class="n">block_to_events</span>

<span class="kn">from</span> <span class="nn">version</span> <span class="kn">import</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">revision</span>


<div class="viewcode-block" id="Sequence">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence">[docs]</a>
<span class="k">class</span> <span class="nc">Sequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate sequences and read/write sequence files. This class defines properties and methods to define a complete MR</span>
<span class="sd">    sequence including RF pulses, gradients, ADC events, etc. The class provides an implementation of the open MR</span>
<span class="sd">    sequence format defined by the Pulseq project. See http://pulseq.github.io/.</span>

<span class="sd">    See also `demo_read.py`, `demo_write.py`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">version_major</span> <span class="o">=</span> <span class="n">major</span>
    <span class="n">version_minor</span> <span class="o">=</span> <span class="n">minor</span>
    <span class="n">version_revision</span> <span class="o">=</span> <span class="n">revision</span>

<div class="viewcode-block" id="Sequence.__init__">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_block_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">system</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">Opts</span><span class="p">()</span>
            
        <span class="c1"># =========</span>
        <span class="c1"># EVENT LIBRARIES</span>
        <span class="c1"># =========</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adc_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>  <span class="c1"># Library of ADC events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>  <span class="c1"># Library of delay events</span>
        <span class="c1"># Library of extension events. Extension events form single-linked zero-terminated lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>  <span class="c1"># Library of gradient events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_inc_library</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">EventLibrary</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># Library of Label(inc) events (reference from the extensions library)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_set_library</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">EventLibrary</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># Library of Label(set) events (reference from the extensions library)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rf_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>  <span class="c1"># Library of RF events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">(</span><span class="n">numpy_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Library of compressed shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_library</span> <span class="o">=</span> <span class="n">EventLibrary</span><span class="p">()</span>  <span class="c1"># Library of trigger events</span>

        <span class="c1"># =========</span>
        <span class="c1"># OTHER</span>
        <span class="c1"># =========</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">system</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># Event table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_block_cache</span> <span class="o">=</span> <span class="n">use_block_cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Block cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Optional sequence definitions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">rf_raster_time</span>
        <span class="p">)</span>  <span class="c1"># RF raster time (system dependent)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">grad_raster_time</span>
        <span class="p">)</span>  <span class="c1"># Gradient raster time (system dependent)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adc_raster_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">adc_raster_time</span>
        <span class="p">)</span>  <span class="c1"># ADC raster time (system dependent)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_duration_raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">block_duration_raster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_definition</span><span class="p">(</span><span class="s2">&quot;AdcRasterTime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">adc_raster_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_definition</span><span class="p">(</span><span class="s2">&quot;BlockDurationRaster&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_duration_raster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_definition</span><span class="p">(</span><span class="s2">&quot;GradientRasterTime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_definition</span><span class="p">(</span><span class="s2">&quot;RadiofrequencyRasterTime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature_type</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature_file</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature_value</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Cache of block durations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># numeric IDs of the used extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># string IDs of the used extensions</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Sequence:&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">shape_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_library</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">rf_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rf_library</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">grad_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">adc_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adc_library</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">delay_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delay_library</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">extensions_library: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extensions_library</span>
        <span class="p">)</span>  <span class="c1"># inserted for trigger support by mveldmann</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">rf_raster_time: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">grad_raster_time: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">block_events: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Sequence.adc_times">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.adc_times">[docs]</a>
    <span class="k">def</span> <span class="nf">adc_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return time points of ADC sampling points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t_adc: np.ndarray</span>
<span class="sd">            Contains times of all ADC sample points.</span>
<span class="sd">        fp_adc : np.ndarray</span>
<span class="sd">            Contains frequency and phase offsets of each ADC object (not samples).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Collect ADC timing data</span>
        <span class="n">t_adc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fp_adc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">curr_dur</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">time_range</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time range must be list of two elements&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End time of time_range must be after begin time&#39;</span><span class="p">)</span>
            
            <span class="c1"># Calculate end times of each block</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>
            <span class="c1"># Search block end times for start of time range</span>
            <span class="n">begin_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Search block begin times for end of time range</span>
            <span class="n">end_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">bd</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">begin_block</span><span class="p">:</span><span class="n">end_block</span><span class="p">]</span>
            <span class="n">curr_dur</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span>
            
        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># ADC</span>
                <span class="n">t_adc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">dwell</span>
                    <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">delay</span>
                    <span class="o">+</span> <span class="n">curr_dur</span>
                <span class="p">)</span>
                <span class="n">fp_adc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">])</span>

            <span class="n">curr_dur</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">t_adc</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="c1"># If there are no ADCs, make sure the output is the right shape</span>
            <span class="n">t_adc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fp_adc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_adc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">t_adc</span><span class="p">)</span>
            <span class="n">fp_adc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp_adc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t_adc</span><span class="p">,</span> <span class="n">fp_adc</span></div>


<div class="viewcode-block" id="Sequence.add_block">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.add_block">[docs]</a>
    <span class="k">def</span> <span class="nf">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">SimpleNamespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new block/multiple events to the sequence. Adds a sequence block with provided as a block structure</span>

<span class="sd">        See also:</span>
<span class="sd">        - `pypulseq.Sequence.sequence.Sequence.set_block()`</span>
<span class="sd">        - `pypulseq.make_adc.make_adc()`</span>
<span class="sd">        - `pypulseq.make_trapezoid.make_trapezoid()`</span>
<span class="sd">        - `pypulseq.make_sinc_pulse.make_sinc_pulse()`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : SimpleNamespace</span>
<span class="sd">            Block structure or events to be added as a block to `Sequence`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block</span><span class="o">.</span><span class="n">set_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span> <span class="o">+=</span> <span class="mi">1</span></div>

    
<div class="viewcode-block" id="Sequence.calculate_gradient_spectrum">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.calculate_gradient_spectrum">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_gradient_spectrum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
            <span class="n">window_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
            <span class="n">frequency_oversampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
            <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">combine_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span>
            <span class="n">use_derivative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">acoustic_resonances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the gradient spectrum of the sequence. Returns a spectrogram</span>
<span class="sd">        for each gradient channel, as well as a root-sum-squares combined</span>
<span class="sd">        spectrogram.</span>
<span class="sd">        </span>
<span class="sd">        Works by splitting the sequence into windows that are &#39;window_width&#39;</span>
<span class="sd">        long and calculating the fourier transform of each window. Windows</span>
<span class="sd">        overlap 50% with the previous and next window. When &#39;combine_mode&#39; is</span>
<span class="sd">        not &#39;none&#39;, all windows are combined into one spectrogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency to include in spectrograms. The default is 2000.</span>
<span class="sd">        window_width : float, optional</span>
<span class="sd">            Window width (in seconds). The default is 0.05.</span>
<span class="sd">        frequency_oversampling : float, optional</span>
<span class="sd">            Oversampling in the frequency dimension, higher values make</span>
<span class="sd">            smoother spectrograms. The default is 3.</span>
<span class="sd">        time_range : List[float], optional</span>
<span class="sd">            Time range over which to calculate the spectrograms as a list of</span>
<span class="sd">            two timepoints (in seconds) (e.g. [1, 1.5])</span>
<span class="sd">            The default is None.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            Whether to plot the spectograms. The default is True.</span>
<span class="sd">        combine_mode : str, optional</span>
<span class="sd">            How to combine all windows into one spectrogram, options:</span>
<span class="sd">                &#39;max&#39;, &#39;mean&#39;, &#39;sos&#39; (root-sum-of-squares), &#39;none&#39; (no combination)</span>
<span class="sd">            The default is &#39;max&#39;.</span>
<span class="sd">        use_derivative : bool, optional</span>
<span class="sd">            Whether the use the derivative of the gradient waveforms instead of the</span>
<span class="sd">            gradient waveforms for the gradient spectrum calculations. The default</span>
<span class="sd">            is False</span>
<span class="sd">        acoustic_resonances : List[dict], optional</span>
<span class="sd">            Acoustic resonances as a list of dictionaries with &#39;frequency&#39; and</span>
<span class="sd">            &#39;bandwidth&#39; elements. Only used when plot==True. The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrograms : List[np.ndarray]</span>
<span class="sd">            List of spectrograms per gradient channel.</span>
<span class="sd">        spectrogram_sos : np.ndarray</span>
<span class="sd">            Root-sum-of-squares combined spectrogram over all gradient channels.</span>
<span class="sd">        frequencies : np.ndarray</span>
<span class="sd">            Frequency axis of the spectrograms.</span>
<span class="sd">        times : np.ndarray</span>
<span class="sd">            Time axis of the spectrograms (only relevant when combine_mode == &#39;none&#39;).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calculate_gradient_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">,</span>
                                           <span class="n">window_width</span><span class="o">=</span><span class="n">window_width</span><span class="p">,</span>
                                           <span class="n">frequency_oversampling</span><span class="o">=</span><span class="n">frequency_oversampling</span><span class="p">,</span>
                                           <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">,</span>
                                           <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                                           <span class="n">combine_mode</span><span class="o">=</span><span class="n">combine_mode</span><span class="p">,</span>
                                           <span class="n">use_derivative</span><span class="o">=</span><span class="n">use_derivative</span><span class="p">,</span>
                                           <span class="n">acoustic_resonances</span><span class="o">=</span><span class="n">acoustic_resonances</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Sequence.calculate_kspace">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.calculate_kspace">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_kspace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trajectory_delay</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">gradient_offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the k-space trajectory of the entire pulse sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trajectory_delay : float or list, default=0</span>
<span class="sd">            Compensation factor in seconds (s) to align ADC and gradients in the reconstruction.</span>
<span class="sd">        gradient_offset : float or list, default=0</span>
<span class="sd">            Simulates background gradients (specified in Hz/m)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k_traj_adc : numpy.array</span>
<span class="sd">            K-space trajectory sampled at `t_adc` timepoints.</span>
<span class="sd">        k_traj : numpy.array</span>
<span class="sd">            K-space trajectory of the entire pulse sequence.</span>
<span class="sd">        t_excitation : List[float]</span>
<span class="sd">            Excitation timepoints.</span>
<span class="sd">        t_refocusing : List[float]</span>
<span class="sd">            Refocusing timepoints.</span>
<span class="sd">        t_adc : numpy.array</span>
<span class="sd">            Sampling timepoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">100e-6</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Trajectory delay of </span><span class="si">{</span><span class="n">trajectory_delay</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e6</span><span class="si">}</span><span class="s2"> us is suspiciously high&quot;</span>
            <span class="p">)</span>

        <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">t_excitation</span><span class="p">,</span> <span class="n">fp_excitation</span><span class="p">,</span> <span class="n">t_refocusing</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_times</span><span class="p">()</span>
        <span class="n">t_adc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adc_times</span><span class="p">()</span>

        <span class="c1"># Convert data to piecewise polynomials</span>
        <span class="n">gw_pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gradients</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">,</span> <span class="n">gradient_offset</span><span class="p">)</span>
        <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gw_pp</span><span class="p">)</span>
        
        <span class="c1"># Calculate slice positions. For now we entirely rely on the excitation -- ignoring complicated interleaved</span>
        <span class="c1"># refocused sequences</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Position in x, y, z</span>
            <span class="n">slice_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ng</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">gw_pp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">slice_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Check for divisions by zero to avoid numpy warning</span>
                    <span class="n">divisor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gw_pp</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">t_excitation</span><span class="p">))</span>
                    <span class="n">slice_pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp_excitation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">[</span><span class="n">divisor</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span>
                    <span class="n">slice_pos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    
            <span class="n">slice_pos</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">slice_pos</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Reset undefined to 0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_pos</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># =========</span>
        <span class="c1"># Integrate waveforms as PPs to produce gradient moments</span>
        <span class="n">gm_pp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gw_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gm_pp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="n">gm_pp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gw_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">())</span>
            <span class="n">tc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># &quot;Sample&quot; ramps for display purposes otherwise piecewise-linear display (plot) fails</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>
            
            <span class="c1"># Do nothing if there are no ramps</span>
            <span class="k">if</span> <span class="n">ii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="p">))</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="p">))</span>
            
            <span class="c1"># Create all ranges starts[0]:ends[0], starts[1]:ends[1], etc.</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="n">ends</span><span class="o">-</span><span class="n">starts</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="c1"># Calculate output index where each range will start</span>
            <span class="n">start_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span><span class="n">lengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            <span class="c1"># Create element-wise differences that will cumsum into</span>
            <span class="c1"># the final indices: [starts[0], 1, 1, starts[1]-starts[0]-lengths[0]+1, 1, etc.]</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">start_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">starts</span><span class="p">)</span> <span class="o">-</span> <span class="n">lengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">tc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tc</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">tc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>
        
            
        <span class="n">t_acc</span> <span class="o">=</span> <span class="mf">1e-10</span>  <span class="c1"># Temporal accuracy</span>
        <span class="n">t_acc_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">t_acc</span>
        <span class="c1"># tc = self.__flatten_jagged_arr(tc)</span>
        <span class="n">t_ktraj</span> <span class="o">=</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">t_acc_inv</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">t_excitation</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_refocusing</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">t_refocusing</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">t_adc</span><span class="p">,</span>
                        <span class="n">total_duration</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">i_excitation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">,</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_acc_inv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)))</span>
        <span class="n">i_refocusing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">,</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_acc_inv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_refocusing</span><span class="p">)))</span>
        <span class="n">i_adc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">,</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_acc_inv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_adc</span><span class="p">)))</span>
        
        <span class="n">i_periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">i_excitation</span><span class="p">,</span> <span class="o">*</span><span class="n">i_refocusing</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_excitation</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ii_next_excitation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ii_next_excitation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_refocusing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ii_next_refocusing</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ii_next_refocusing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">k_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ng</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gw_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">t_ktraj</span> <span class="o">&gt;=</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">t_acc_inv</span> <span class="o">*</span> <span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">t_ktraj</span> <span class="o">&lt;=</span> <span class="n">t_acc</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">t_acc_inv</span> <span class="o">*</span> <span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k_traj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">gm_pp</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">t_ktraj</span><span class="p">[</span><span class="n">it</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">t_ktraj</span><span class="p">[</span><span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">t_ktraj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">k_traj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">k_traj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Convert gradient moments to kspace</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="o">-</span><span class="n">k_traj</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_periods</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">i_period</span> <span class="o">=</span> <span class="n">i_periods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i_period_end</span> <span class="o">=</span> <span class="n">i_periods</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ii_next_excitation</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i_excitation</span><span class="p">[</span><span class="n">ii_next_excitation</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_period</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t_ktraj</span><span class="p">[</span><span class="n">i_period</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_excitation</span><span class="p">[</span><span class="n">ii_next_excitation</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">t_acc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;abs(t_ktraj[i_period]-t_excitation[ii_next_excitation]) &lt; </span><span class="si">{</span><span class="n">t_acc</span><span class="si">}</span><span class="s2"> failed for ii_next_excitation=</span><span class="si">{</span><span class="n">ii_next_excitation</span><span class="si">}</span><span class="s2"> error=</span><span class="si">{</span><span class="n">t_ktraj</span><span class="p">(</span><span class="n">i_period</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_excitation</span><span class="p">(</span><span class="n">ii_next_excitation</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="o">-</span><span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i_period</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Use nans to mark the excitation points since they interrupt the plots</span>
                    <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="c1"># -1 on len(i_excitation) for 0-based indexing</span>
                <span class="n">ii_next_excitation</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_excitation</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ii_next_excitation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">ii_next_refocusing</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i_refocusing</span><span class="p">[</span><span class="n">ii_next_refocusing</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_period</span>
            <span class="p">):</span>
                <span class="c1"># dk = -k_traj[:, i_period]</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period</span><span class="p">]</span> <span class="o">-</span> <span class="n">dk</span>
                <span class="c1"># -1 on len(i_excitation) for 0-based indexing</span>
                <span class="n">ii_next_refocusing</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_refocusing</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ii_next_refocusing</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period</span><span class="p">:</span><span class="n">i_period_end</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period</span><span class="p">:</span><span class="n">i_period_end</span><span class="p">]</span> <span class="o">+</span> <span class="n">dk</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_period_end</span><span class="p">]</span> <span class="o">+</span> <span class="n">dk</span>
        <span class="n">k_traj_adc</span> <span class="o">=</span> <span class="n">k_traj</span><span class="p">[:,</span> <span class="n">i_adc</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">k_traj_adc</span><span class="p">,</span> <span class="n">k_traj</span><span class="p">,</span> <span class="n">t_excitation</span><span class="p">,</span> <span class="n">t_refocusing</span><span class="p">,</span> <span class="n">t_adc</span></div>


    <span class="k">def</span> <span class="nf">calculate_kspacePP</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">trajectory_delay</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">gradient_offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Sequence.calculate_kspacePP has been deprecated, use calculate_kspace instead&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_kspace</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">,</span> <span class="n">gradient_offset</span><span class="p">)</span>

<div class="viewcode-block" id="Sequence.calculate_pns">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.calculate_pns">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_pns</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">hardware</span><span class="p">:</span> <span class="n">SimpleNamespace</span><span class="p">,</span>
            <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">do_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate PNS using safe model implementation by Szczepankiewicz and Witzel</span>
<span class="sd">        See http://github.com/filip-szczepankiewicz/safe_pns_prediction</span>
<span class="sd">        </span>
<span class="sd">        Returns pns levels due to respective axes (normalized to 1 and not to 100#)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hardware : SimpleNamespace</span>
<span class="sd">            Hardware specifications. See safe_example_hw() from</span>
<span class="sd">            the safe_pns_prediction package. Alternatively a text file</span>
<span class="sd">            in the .asc format (Siemens) can be passed, e.g. for Prisma</span>
<span class="sd">            it is MP_GPA_K2309_2250V_951A_AS82.asc (we leave it as an</span>
<span class="sd">            exercise to the interested user to find were these files</span>
<span class="sd">            can be acquired from)</span>
<span class="sd">        do_plots : bool, optional</span>
<span class="sd">            Plot the results from the PNS calculations. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ok : bool</span>
<span class="sd">            Boolean flag indicating whether peak PNS is within acceptable limits</span>
<span class="sd">        pns_norm : numpy.array [N]</span>
<span class="sd">            PNS norm over all gradient channels, normalized to 1</span>
<span class="sd">        pns_components : numpy.array [Nx3]</span>
<span class="sd">            PNS levels per gradient channel</span>
<span class="sd">        t_pns : np.array [N]</span>
<span class="sd">            Time axis for the pns_norm and pns_components arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calc_pns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hardware</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">,</span> <span class="n">do_plots</span><span class="o">=</span><span class="n">do_plots</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequence.check_timing">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.check_timing">[docs]</a>
    <span class="k">def</span> <span class="nf">check_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks timing of all blocks and objects in the sequence optionally returns the detailed error log. This</span>
<span class="sd">        function also modifies the sequence object by adding the field &quot;TotalDuration&quot; to sequence definitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_ok : bool</span>
<span class="sd">            Boolean flag indicating timing errors.</span>
<span class="sd">        error_report : str</span>
<span class="sd">            Error report in case of timing errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error_report</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">total_duration</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">block_to_events</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">ext_check_timing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">)</span>
            <span class="n">is_ok</span> <span class="o">=</span> <span class="n">is_ok</span> <span class="ow">and</span> <span class="n">res</span>

            <span class="c1"># Check the stored total block duration</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">duration</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">+=</span> <span class="s2">&quot;Inconsistency between the stored block duration and the duration of the block content&quot;</span>
                <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>

            <span class="c1"># Check RF dead times</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">delay</span> <span class="o">-</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">dead_time</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
                    <span class="n">rep</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Delay of </span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">delay</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e6</span><span class="si">}</span><span class="s2"> us is smaller than the RF dead time &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">dead_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e6</span><span class="si">}</span><span class="s2"> us&quot;</span>
                    <span class="p">)</span>
                    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">ringdown_time</span> <span class="o">-</span> <span class="n">duration</span>
                    <span class="o">&gt;</span> <span class="n">eps</span>
                <span class="p">):</span>
                    <span class="n">rep</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Time between the end of the RF pulse at </span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">delay</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> and the end &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of the block at </span><span class="si">{</span><span class="n">duration</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e6</span><span class="si">}</span><span class="s2"> us is shorter than rf_ringdown_time&quot;</span>
                    <span class="p">)</span>
                    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Check ADC dead times</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">delay</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">adc_dead_time</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
                    <span class="n">rep</span> <span class="o">+=</span> <span class="s2">&quot;adc.delay &lt; system.adc_dead_time&quot;</span>
                    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">delay</span>
                    <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">dwell</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">adc_dead_time</span>
                    <span class="o">-</span> <span class="n">duration</span>
                    <span class="o">&gt;</span> <span class="n">eps</span>
                <span class="p">):</span>
                    <span class="n">rep</span> <span class="o">+=</span> <span class="s2">&quot;adc: system.adc_dead_time (post-ADC) violation&quot;</span>
                    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Update report</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">error_report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Event: </span><span class="si">{</span><span class="n">block_counter</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">rep</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">total_duration</span> <span class="o">+=</span> <span class="n">duration</span>

        <span class="c1"># Check if all the gradients in the last block are ramped down properly</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">SimpleNamespace</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">events</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;grad&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">events</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">last</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">error_report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Event: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> - Gradients do not ramp to 0 at the end of the sequence&quot;</span>
                        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_definition</span><span class="p">(</span><span class="s2">&quot;TotalDuration&quot;</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">is_ok</span><span class="p">,</span> <span class="n">error_report</span></div>


<div class="viewcode-block" id="Sequence.duration">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.duration">[docs]</a>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total duration of this sequence, and the total count of blocks and events.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        duration : int</span>
<span class="sd">            Duration of this sequence in seconds (s).</span>
<span class="sd">        num_blocks : int</span>
<span class="sd">            Number of blocks in this sequence.</span>
<span class="sd">        event_count : np.ndarray</span>
<span class="sd">            Number of events in this sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">)</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">event_count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">duration</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">duration</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="n">event_count</span></div>


<div class="viewcode-block" id="Sequence.evaluate_labels">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.evaluate_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">init</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">evolution</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate label values of the entire sequence.</span>
<span class="sd">        </span>
<span class="sd">        When no evolution is given, returns the label values at the end of the</span>
<span class="sd">        sequence. Returns a dictionary with keys named after the labels used</span>
<span class="sd">        in the sequence. Only the keys corresponding to the labels actually</span>
<span class="sd">        used are created.</span>
<span class="sd">        E.g. labels[&#39;LIN&#39;] == 4</span>
<span class="sd">        </span>
<span class="sd">        When evolution is given, labels are tracked through the sequence. See</span>
<span class="sd">        below for options for different types of evolutions. The resulting</span>
<span class="sd">        dictionary will contain arrays of the label values.</span>
<span class="sd">        E.g. labels[&#39;LIN&#39;] == np.array([0,1,2,3,4])</span>
<span class="sd">        </span>
<span class="sd">        Initial values for the labels can be given with the &#39;init&#39; parameter.</span>
<span class="sd">        Useful if evaluating labels block-by-block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        init : dict, optional</span>
<span class="sd">            Dictionary containing initial label values. The default is None.</span>
<span class="sd">        evolution : str, optional</span>
<span class="sd">            Flag to specify tracking of label evolutions.</span>
<span class="sd">            Must be one of: &#39;none&#39;, &#39;adc&#39;, &#39;label&#39;, &#39;blocks&#39; (default = &#39;none&#39;)</span>
<span class="sd">            &#39;blocks&#39;: Return label values for all blocks.</span>
<span class="sd">            &#39;adc&#39;:    Return label values only for blocks containing ADC events.</span>
<span class="sd">            &#39;label&#39;:  Return label values only for blocks where labels are</span>
<span class="sd">                      manipulated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : dict</span>
<span class="sd">            Dictionary containing label values.</span>
<span class="sd">            If evolution == &#39;none&#39;, the dictionary values only contains the</span>
<span class="sd">            final label value.</span>
<span class="sd">            Otherwise, the dictionary values are arrays of label evolutions.</span>
<span class="sd">            Only the labels that are used in the sequence are created in the</span>
<span class="sd">            dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">init</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">label_evolution</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># TODO: MATLAB implementation includes block_range parameter. But in</span>
        <span class="c1">#       general we cannot assume linear block ordering. Could include</span>
        <span class="c1">#       time_range like in other sequence functions. Or a blocks</span>
        <span class="c1">#       parameter to specify which blocks to loop over?</span>
        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Current block has labels</span>
                <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">lab</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;labelinc&#39;</span><span class="p">:</span>
                        <span class="c1"># Increment label</span>
                        <span class="k">if</span> <span class="n">lab</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                            <span class="n">labels</span><span class="p">[</span><span class="n">lab</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        
                        <span class="n">labels</span><span class="p">[</span><span class="n">lab</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lab</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Set label</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">lab</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">value</span>
                
                <span class="k">if</span> <span class="n">evolution</span> <span class="o">==</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span>
                    <span class="n">label_evolution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">evolution</span> <span class="o">==</span> <span class="s1">&#39;blocks&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">evolution</span> <span class="o">==</span> <span class="s1">&#39;adc&#39;</span> <span class="ow">and</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">label_evolution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        
        <span class="c1"># Convert evolutions into label dictionary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_evolution</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="k">if</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">e</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">label_evolution</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="Sequence.flip_grad_axis">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.flip_grad_axis">[docs]</a>
    <span class="k">def</span> <span class="nf">flip_grad_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invert all gradients along the corresponding axis/channel. The function acts on all gradient objects already</span>
<span class="sd">        added to the sequence object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str</span>
<span class="sd">            Gradients to invert or scale. Must be one of &#39;x&#39;, &#39;y&#39; or &#39;z&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mod_grad_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">modifier</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequence.get_block">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.get_block">[docs]</a>
    <span class="k">def</span> <span class="nf">get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimpleNamespace</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a block of the sequence  specified by the index. The block is created from the sequence data with all</span>
<span class="sd">        events and shapes decompressed.</span>

<span class="sd">        See also:</span>
<span class="sd">        - `pypulseq.Sequence.sequence.Sequence.set_block()`.</span>
<span class="sd">        - `pypulseq.Sequence.sequence.Sequence.add_block()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        block_index : int</span>
<span class="sd">            Index of block to be retrieved from `Sequence`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SimpleNamespace</span>
<span class="sd">            Event identified by `block_index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequence.get_definition">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.get_definition">[docs]</a>
    <span class="k">def</span> <span class="nf">get_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return value of the definition specified by the key. These definitions can be added manually or read from the</span>
<span class="sd">        header of a sequence file defined in the sequence header. An empty array is returned if the key is not defined.</span>

<span class="sd">        See also `pypulseq.Sequence.sequence.Sequence.set_definition()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Key of definition to retrieve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Definition identified by `key` if found, else returns &#39;&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Sequence.get_extension_type_ID">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.get_extension_type_ID">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extension_type_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extension_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get numeric extension ID for `extension_string`. Will automatically create a new ID if unknown.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extension_string : str</span>
<span class="sd">            Given string extension ID.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extension_id : int</span>
<span class="sd">            Numeric ID for given string extension ID.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extension_string</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extension_id</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extension_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extension_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extension_string</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">extension_string</span><span class="p">)</span>
            <span class="n">extension_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">extension_id</span></div>


<div class="viewcode-block" id="Sequence.get_extension_type_string">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.get_extension_type_string">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extension_type_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extension_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string extension ID for `extension_id`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extension_id : int</span>
<span class="sd">            Given numeric extension ID.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extension_str : str</span>
<span class="sd">            String ID for the given numeric extension ID.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If given numeric extension ID is unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extension_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">extension_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Extension for the given ID - </span><span class="si">{</span><span class="n">extension_id</span><span class="si">}</span><span class="s2"> - is unknown.&quot;</span>
            <span class="p">)</span>

        <span class="n">extension_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">extension_str</span></div>


<div class="viewcode-block" id="Sequence.get_gradients">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.get_gradients">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">trajectory_delay</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">gradient_offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PPoly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all gradient waveforms of the sequence in a piecewise-polynomial</span>
<span class="sd">        format (scipy PPoly). Gradient values can be accessed easily at one or</span>
<span class="sd">        more timepoints using `gw_pp[channel](t)` (where t is a float, list of</span>
<span class="sd">        floats, or numpy array). Note that PPoly objects return nan for</span>
<span class="sd">        timepoints outside the waveform.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trajectory_delay : float or list, default=0</span>
<span class="sd">            Compensation factor in seconds (s) to align ADC and gradients in the reconstruction.</span>
<span class="sd">        gradient_offset : float or list, default=0</span>
<span class="sd">            Simulates background gradients (specified in Hz/m)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gw_pp : List[PPoly]</span>
<span class="sd">            List of gradient waveforms for each of the gradient channels,</span>
<span class="sd">            expressed as scipy PPoly objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">100e-6</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Trajectory delay of </span><span class="si">{</span><span class="n">trajectory_delay</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e6</span><span class="si">}</span><span class="s2"> us is suspiciously high&quot;</span>
            <span class="p">)</span>

        <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        
        <span class="n">gw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>
        <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gw_data</span><span class="p">)</span>
        
        <span class="c1"># Gradient delay handling</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">gradient_delays</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajectory_delay</span><span class="p">]</span> <span class="o">*</span> <span class="n">ng</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trajectory_delay</span><span class="p">)</span> <span class="o">==</span> <span class="n">ng</span><span class="p">)</span>  <span class="c1"># Need to have same number of gradient channels</span>
            <span class="n">gradient_delays</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajectory_delay</span><span class="p">]</span> <span class="o">*</span> <span class="n">ng</span>

        <span class="c1"># Gradient offset handling</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gradient_offset</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">gradient_offset</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradient_offset</span><span class="p">]</span> <span class="o">*</span> <span class="n">ng</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradient_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">ng</span><span class="p">)</span>  <span class="c1"># Need to have same number of gradient channels</span>

        <span class="c1"># Convert data to piecewise polynomials</span>
        <span class="n">gw_pp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
            <span class="n">wave_cnt</span> <span class="o">=</span> <span class="n">gw_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient_offset</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                    <span class="n">gw_pp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gw</span> <span class="o">=</span> <span class="n">gw_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># Now gw contains the waveform from the current axis</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient_delays</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">gradient_delays</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  <span class="c1"># Anisotropic gradient delay support</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gw</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;Not all elements of the generated waveform are finite.&quot;</span><span class="p">)</span>

            <span class="n">teps</span> <span class="o">=</span> <span class="mf">1e-12</span>
            <span class="n">_temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">teps</span><span class="p">,</span> <span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">teps</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">_temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">teps</span><span class="p">,</span> <span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">teps</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">gw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">_temp1</span><span class="p">,</span> <span class="n">gw</span><span class="p">,</span> <span class="n">_temp2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient_offset</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">gw</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">gradient_offset</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">gw</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">gw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">gw_pp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PPoly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">gw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                         <span class="n">gw</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">gw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">gw_pp</span></div>


<div class="viewcode-block" id="Sequence.mod_grad_axis">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.mod_grad_axis">[docs]</a>
    <span class="k">def</span> <span class="nf">mod_grad_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">modifier</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invert or scale all gradients along the corresponding axis/channel. The function acts on all gradient objects</span>
<span class="sd">        already added to the sequence object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str</span>
<span class="sd">            Gradients to invert or scale. Must be one of &#39;x&#39;, &#39;y&#39; or &#39;z&#39;.</span>
<span class="sd">        modifier : int</span>
<span class="sd">            Scaling value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid `axis` is passed. Must be one of &#39;x&#39;, &#39;y&#39;,&#39;z&#39;.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If same gradient event is used on multiple axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid axis. Must be one of &#39;x&#39;, &#39;y&#39;,&#39;z&#39;. Passed: </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">channel_num</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">other_channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">other_channels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">channel_num</span><span class="p">)</span>

        <span class="c1"># Go through all event table entries and list gradient objects in the library</span>
        <span class="n">all_grad_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">all_grad_events</span> <span class="o">=</span> <span class="n">all_grad_events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

        <span class="n">selected_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_grad_events</span><span class="p">[:,</span> <span class="n">channel_num</span><span class="p">])</span>
        <span class="n">selected_events</span> <span class="o">=</span> <span class="n">selected_events</span><span class="p">[</span><span class="n">selected_events</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">other_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_grad_events</span><span class="p">[:,</span> <span class="n">other_channels</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">selected_events</span><span class="p">,</span> <span class="n">other_events</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;mod_grad_axis does not yet support the same gradient event used on multiple axes.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_events</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">selected_events</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">modifier</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">selected_events</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">selected_events</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">5</span>
            <span class="p">):</span>
                <span class="c1"># Need to update first and last fields</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">selected_events</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">modifier</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">selected_events</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="n">modifier</span></div>


<div class="viewcode-block" id="Sequence.plot">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(),</span>
        <span class="n">show_blocks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>
        <span class="n">time_disp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
        <span class="n">grad_disp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kHz/m&quot;</span><span class="p">,</span>
        <span class="n">plot_now</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot `Sequence`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str, defualt=str()</span>
<span class="sd">            Plot label values for ADC events: in this example for LIN and REP labels; other valid labes are accepted as</span>
<span class="sd">            a comma-separated list.</span>
<span class="sd">        save : bool, default=False</span>
<span class="sd">            Boolean flag indicating if plots should be saved. The two figures will be saved as JPG with numerical</span>
<span class="sd">            suffixes to the filename &#39;seq_plot&#39;.</span>
<span class="sd">        show_blocks : bool, default=False</span>
<span class="sd">            Boolean flag to indicate if grid and tick labels at the block boundaries are to be plotted.</span>
<span class="sd">        time_range : iterable, default=(0, np.inf)</span>
<span class="sd">            Time range (x-axis limits) for plotting the sequence. Default is 0 to infinity (entire sequence).</span>
<span class="sd">        time_disp : str, default=&#39;s&#39;</span>
<span class="sd">            Time display type, must be one of `s`, `ms` or `us`.</span>
<span class="sd">        grad_disp : str, default=&#39;s&#39;</span>
<span class="sd">            Gradient display unit, must be one of `kHz/m` or `mT/m`.</span>
<span class="sd">        plot_now : bool, default=True</span>
<span class="sd">            If true, function immediately shows the plots, blocking the rest of the code until plots are exited.</span>
<span class="sd">            If false, plots are shown when plt.show() is called. Useful if plots are to be modified.</span>
<span class="sd">        plot_type : str, default=&#39;Gradient&#39;</span>
<span class="sd">            Gradients display type, must be one of either &#39;Gradient&#39; or &#39;Kspace&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.75</span>  <span class="c1"># Set default Matplotlib linewidth</span>

        <span class="n">valid_time_units</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">]</span>
        <span class="n">valid_grad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kHz/m&quot;</span><span class="p">,</span> <span class="s2">&quot;mT/m&quot;</span><span class="p">]</span>
        <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">get_supported_labels</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">])</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_disp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_time_units</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported time unit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grad_disp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_grad_units</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported gradient unit. Supported gradient units are: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">valid_grad_units</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">fig1</span><span class="p">,</span> <span class="n">fig2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sp11</span> <span class="o">=</span> <span class="n">fig1</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">)</span>
        <span class="n">sp12</span> <span class="o">=</span> <span class="n">fig1</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sp11</span><span class="p">)</span>
        <span class="n">sp13</span> <span class="o">=</span> <span class="n">fig1</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sp11</span><span class="p">)</span>
        <span class="n">fig2_subplots</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sp11</span><span class="p">),</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sp11</span><span class="p">),</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sp11</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="n">t_factor_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">]</span>
        <span class="n">t_factor</span> <span class="o">=</span> <span class="n">t_factor_list</span><span class="p">[</span><span class="n">valid_time_units</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">time_disp</span><span class="p">)]</span>

        <span class="n">g_factor_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">gamma</span><span class="p">]</span>
        <span class="n">g_factor</span> <span class="o">=</span> <span class="n">g_factor_list</span><span class="p">[</span><span class="n">valid_grad_units</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">grad_disp</span><span class="p">)]</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">label_defined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">label_idx_to_plot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_legend_to_plot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_store</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_labels</span><span class="p">)):</span>
            <span class="n">label_store</span><span class="p">[</span><span class="n">valid_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">valid_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                <span class="n">label_idx_to_plot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">label_legend_to_plot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_idx_to_plot</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parula</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label_idx_to_plot</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">label_colors_to_plot</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label_idx_to_plot</span><span class="p">)))</span>
            <span class="n">cycler</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cycler</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">label_colors_to_plot</span><span class="p">)</span>
            <span class="n">sp11</span><span class="o">.</span><span class="n">set_prop_cycle</span><span class="p">(</span><span class="n">cycler</span><span class="p">)</span>


        <span class="c1"># Block timings</span>
        <span class="n">block_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
        <span class="n">block_edges_in_range</span> <span class="o">=</span> <span class="n">block_edges</span><span class="p">[</span>
            <span class="p">(</span><span class="n">block_edges</span> <span class="o">&gt;=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">block_edges</span> <span class="o">&lt;=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">show_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sp11</span><span class="p">,</span> <span class="n">sp12</span><span class="p">,</span> <span class="n">sp13</span><span class="p">,</span> <span class="o">*</span><span class="n">fig2_subplots</span><span class="p">]:</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">t_factor</span> <span class="o">*</span> <span class="n">block_edges_in_range</span><span class="p">)</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;labelinc&quot;</span><span class="p">:</span>
                            <span class="n">label_store</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">label_store</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                    <span class="n">label_defined</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="s2">&quot;adc&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># ADC</span>
                    <span class="n">adc</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span>
                    <span class="c1"># From Pulseq: According to the information from Klaus Scheffler and indirectly from Siemens this</span>
                    <span class="c1"># is the present convention - the samples are shifted by 0.5 dwell</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">adc</span><span class="o">.</span><span class="n">num_samples</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">dwell</span>
                    <span class="n">sp11</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="s2">&quot;rx&quot;</span><span class="p">)</span>
                    <span class="n">sp13</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">t</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;b.&quot;</span><span class="p">,</span>
                        <span class="n">markersize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">label_defined</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_idx_to_plot</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">arr_label_store</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">label_store</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                        <span class="n">lbl_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">arr_label_store</span><span class="p">,</span> <span class="n">label_idx_to_plot</span><span class="p">)</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">adc</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="p">(</span><span class="n">adc</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">dwell</span>
                        <span class="n">_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_factor</span> <span class="o">*</span> <span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lbl_vals</span><span class="p">)</span>
                        <span class="c1"># Plot each label individually to retrieve each corresponding Line2D object</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">sp11</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">__t</span><span class="p">,</span> <span class="n">_lbl_vals</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">__t</span><span class="p">,</span> <span class="n">_lbl_vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_t</span><span class="p">,</span> <span class="n">lbl_vals</span><span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_legend_to_plot</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">sp11</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label_legend_to_plot</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>
                            <span class="n">label_legend_to_plot</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="s2">&quot;rf&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># RF</span>
                    <span class="n">rf</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span>
                    <span class="n">tc</span><span class="p">,</span> <span class="n">ic</span> <span class="o">=</span> <span class="n">calc_rf_center</span><span class="p">(</span><span class="n">rf</span><span class="p">)</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">t</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">signal</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">signal</span><span class="p">))</span>
                        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">time</span><span class="p">))</span>
                        <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">signal</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>

                    <span class="n">sp12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
                    <span class="n">sp13</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                            <span class="n">signal</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">time</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">tc</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                            <span class="n">signal</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">time</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;xb&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">grad_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gx&quot;</span><span class="p">,</span> <span class="s2">&quot;gy&quot;</span><span class="p">,</span> <span class="s2">&quot;gz&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grad_channels</span><span class="p">)):</span>  <span class="c1"># Gradients</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">grad_channels</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">grad</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">grad_channels</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;grad&quot;</span><span class="p">:</span>
                            <span class="c1"># We extend the shape by adding the first and the last points in an effort of making the</span>
                            <span class="c1"># display a bit less confusing...</span>
                            <span class="n">time</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">shape_dur</span><span class="p">])</span>
                            <span class="n">waveform</span> <span class="o">=</span> <span class="n">g_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">grad</span><span class="o">.</span><span class="n">waveform</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">last</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cumsum</span><span class="p">(</span>
                                    <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">rise_time</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">flat_time</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">fall_time</span><span class="p">,</span>
                            <span class="p">))</span>
                            <span class="n">waveform</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">g_factor</span> <span class="o">*</span> <span class="n">grad</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                            <span class="p">)</span>
                        <span class="n">fig2_subplots</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">time</span><span class="p">),</span> <span class="n">waveform</span><span class="p">)</span>
            <span class="n">t0</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>

        <span class="n">grad_plot_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">sp11</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;ADC&quot;</span><span class="p">)</span>
        <span class="n">sp12</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;RF mag (Hz)&quot;</span><span class="p">)</span>
        <span class="n">sp13</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;RF/ADC phase (rad)&quot;</span><span class="p">)</span>
        <span class="n">sp13</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t (</span><span class="si">{</span><span class="n">time_disp</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">_label</span> <span class="o">=</span> <span class="n">grad_plot_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">fig2_subplots</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;G</span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">grad_disp</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">fig2_subplots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t (</span><span class="si">{</span><span class="n">time_disp</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Setting display limits</span>
        <span class="n">disp_range</span> <span class="o">=</span> <span class="n">t_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">disp_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sp11</span><span class="p">,</span> <span class="n">sp12</span><span class="p">,</span> <span class="n">sp13</span><span class="p">,</span> <span class="o">*</span><span class="n">fig2_subplots</span><span class="p">]]</span>

        <span class="c1"># Grid on</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sp11</span><span class="p">,</span> <span class="n">sp12</span><span class="p">,</span> <span class="n">sp13</span><span class="p">,</span> <span class="o">*</span><span class="n">fig2_subplots</span><span class="p">]:</span>
            <span class="n">sp</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

        <span class="n">fig1</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig2</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">fig1</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;seq_plot1.jpg&quot;</span><span class="p">)</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;seq_plot2.jpg&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_now</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Sequence.read">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">detect_rf_use</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read `.seq` file from `file_path`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detect_rf_use</span>
<span class="sd">        file_path : str</span>
<span class="sd">            Path to `.seq` file to be read.</span>
<span class="sd">        remove_duplicates : bool, default=True</span>
<span class="sd">            Remove duplicate events from the sequence after reading.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_block_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> <span class="n">detect_rf_use</span><span class="o">=</span><span class="n">detect_rf_use</span><span class="p">,</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="n">remove_duplicates</span><span class="p">)</span>

        <span class="c1"># Initialize next free block ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span> <span class="k">else</span> <span class="mi">1</span></div>


    <span class="k">def</span> <span class="nf">register_adc_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">EventLibrary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">register_adc_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_grad_event</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">SimpleNamespace</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">register_grad_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_label_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">SimpleNamespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">register_label_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_rf_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">SimpleNamespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">register_rf_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

<div class="viewcode-block" id="Sequence.remove_duplicates">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.remove_duplicates">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes duplicate events from the shape and event libraries contained</span>
<span class="sd">        in this sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_place : bool, optional</span>
<span class="sd">            If true, removes the duplicates from the current sequence.</span>
<span class="sd">            Otherwise, a copy is created. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        seq_copy : Sequence</span>
<span class="sd">            If `in_place`, returns self. Otherwise returns a copy of the</span>
<span class="sd">            sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">seq_copy</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Avoid copying block_cache for performance</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">seq_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_cache</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Find duplicate in shape library</span>
        <span class="n">seq_copy</span><span class="o">.</span><span class="n">shape_library</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">shape_library</span><span class="o">.</span><span class="n">remove_duplicates</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

        <span class="c1"># Remap shape IDs of arbitrary gradient events</span>
        <span class="k">for</span> <span class="n">grad_id</span> <span class="ow">in</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">grad_id</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">grad_id</span><span class="p">]</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">mapping</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="n">new_data</span><span class="p">:</span>
                    <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grad_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># Remap shape IDs of RF events</span>
        <span class="k">for</span> <span class="n">rf_id</span> <span class="ow">in</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">rf_library</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">rf_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">rf_id</span><span class="p">]</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">mapping</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">mapping</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="n">new_data</span><span class="p">:</span>
                <span class="n">seq_copy</span><span class="o">.</span><span class="n">rf_library</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rf_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># Filter duplicates in gradient library</span>
        <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">grad_library</span><span class="o">.</span><span class="n">remove_duplicates</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">))</span>

        <span class="c1"># Remap gradient event IDs</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
            <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span>

        <span class="c1"># Filter duplicates in RF library</span>
        <span class="n">seq_copy</span><span class="o">.</span><span class="n">rf_library</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">rf_library</span><span class="o">.</span><span class="n">remove_duplicates</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="c1"># Remap RF event IDs</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Filter duplicates in ADC library</span>
        <span class="n">seq_copy</span><span class="o">.</span><span class="n">adc_library</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">adc_library</span><span class="o">.</span><span class="n">remove_duplicates</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="c1"># Remap ADC event IDs</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>
            <span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">seq_copy</span><span class="o">.</span><span class="n">block_events</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">5</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">seq_copy</span></div>



<div class="viewcode-block" id="Sequence.rf_from_lib_data">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.rf_from_lib_data">[docs]</a>
    <span class="k">def</span> <span class="nf">rf_from_lib_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lib_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">use</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">SimpleNamespace</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct RF object from `lib_data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lib_data : list</span>
<span class="sd">            RF envelope.</span>
<span class="sd">        use : str, default=str()</span>
<span class="sd">            RF event use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rf : SimpleNamespace</span>
<span class="sd">            RF object constructed from `lib_data`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="n">rf</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;rf&quot;</span>

        <span class="n">amplitude</span><span class="p">,</span> <span class="n">mag_shape</span><span class="p">,</span> <span class="n">phase_shape</span> <span class="o">=</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">shape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mag_shape</span><span class="p">]</span>
        <span class="n">compressed</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="n">compressed</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">compressed</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">decompress_shape</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span>
        <span class="n">shape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">phase_shape</span><span class="p">]</span>
        <span class="n">compressed</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">compressed</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">decompress_shape</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span>
        <span class="n">rf</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span>
        <span class="n">time_shape</span> <span class="o">=</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">time_shape</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_library</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">time_shape</span><span class="p">]</span>
            <span class="n">compressed</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">compressed</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">rf</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">decompress_shape</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span>
            <span class="n">rf</span><span class="o">.</span><span class="n">shape_dur</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Generate default time raster on the fly</span>
            <span class="n">rf</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span>
            <span class="n">rf</span><span class="o">.</span><span class="n">shape_dur</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_raster_time</span>

        <span class="n">rf</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span> <span class="o">=</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span> <span class="o">=</span> <span class="n">lib_data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>

        <span class="n">rf</span><span class="o">.</span><span class="n">dead_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">rf_dead_time</span>
        <span class="n">rf</span><span class="o">.</span><span class="n">ringdown_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">rf_ringdown_time</span>

        <span class="k">if</span> <span class="n">use</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">use_cases</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;excitation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="s2">&quot;refocusing&quot;</span><span class="p">,</span>
                <span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="s2">&quot;inversion&quot;</span><span class="p">,</span>
                <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="s2">&quot;saturation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="s2">&quot;preparation&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">rf</span><span class="o">.</span><span class="n">use</span> <span class="o">=</span> <span class="n">use_cases</span><span class="p">[</span><span class="n">use</span><span class="p">]</span> <span class="k">if</span> <span class="n">use</span> <span class="ow">in</span> <span class="n">use_cases</span> <span class="k">else</span> <span class="s2">&quot;undefined&quot;</span>

        <span class="k">return</span> <span class="n">rf</span></div>


<div class="viewcode-block" id="Sequence.rf_times">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.rf_times">[docs]</a>
    <span class="k">def</span> <span class="nf">rf_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return time points of excitations and refocusings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t_excitation : List[float]</span>
<span class="sd">            Contains time moments of the excitation RF pulses</span>
<span class="sd">        fp_excitation : np.ndarray</span>
<span class="sd">            Contains frequency and phase offsets of the excitation RF pulses</span>
<span class="sd">        t_refocusing : List[float]</span>
<span class="sd">            Contains time moments of the refocusing RF pulses</span>
<span class="sd">        fp_refocusing : np.ndarray</span>
<span class="sd">            Contains frequency and phase offsets of the excitation RF pulses</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Collect RF timing data</span>
        <span class="n">t_excitation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fp_excitation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_refocusing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fp_refocusing</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">curr_dur</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">time_range</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time range must be list of two elements&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End time of time_range must be after begin time&#39;</span><span class="p">)</span>
            
            <span class="c1"># Calculate end times of each block</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>
            <span class="c1"># Search block end times for start of time range</span>
            <span class="n">begin_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Search block begin times for end of time range</span>
            <span class="n">end_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">bd</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">begin_block</span><span class="p">:</span><span class="n">end_block</span><span class="p">]</span>
            <span class="n">curr_dur</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span>
            
        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># RF</span>
                <span class="n">rf</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">calc_rf_center</span><span class="p">(</span><span class="n">rf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="s2">&quot;use&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">use</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s2">&quot;excitation&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;undefined&quot;</span><span class="p">,</span>
                <span class="p">]:</span>
                    <span class="n">t_excitation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dur</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">fp_excitation</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">use</span> <span class="o">==</span> <span class="s2">&quot;refocusing&quot;</span><span class="p">:</span>
                    <span class="n">t_refocusing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dur</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span>
                    <span class="n">fp_refocusing</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">])</span>

            <span class="n">curr_dur</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fp_excitation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp_excitation</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp_excitation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_refocusing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fp_refocusing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp_refocusing</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp_refocusing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">t_excitation</span><span class="p">,</span> <span class="n">fp_excitation</span><span class="p">,</span> <span class="n">t_refocusing</span><span class="p">,</span> <span class="n">fp_refocusing</span></div>


<div class="viewcode-block" id="Sequence.set_block">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.set_block">[docs]</a>
    <span class="k">def</span> <span class="nf">set_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">SimpleNamespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace block at index with new block provided as block structure, add sequence block, or create a new block</span>
<span class="sd">        from events and store at position specified by index. The block or events are provided in uncompressed form and</span>
<span class="sd">        will be stored in the compressed, non-redundant internal libraries.</span>

<span class="sd">        See also:</span>
<span class="sd">        - `pypulseq.Sequence.sequence.Sequence.get_block()`</span>
<span class="sd">        - `pypulseq.Sequence.sequence.Sequence.add_block()`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        block_index : int</span>
<span class="sd">            Index at which block is replaced.</span>
<span class="sd">        args : SimpleNamespace</span>
<span class="sd">            Block or events to be replaced/added or created at `block_index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block</span><span class="o">.</span><span class="n">set_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block_index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_free_block_ID</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Sequence.set_definition">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.set_definition">[docs]</a>
    <span class="k">def</span> <span class="nf">set_definition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify a custom definition of the sequence. Set the user definition &#39;key&#39; to value &#39;value&#39;. If the definition</span>
<span class="sd">        does not exist it will be created.</span>

<span class="sd">        See also `pypulseq.Sequence.sequence.Sequence.get_definition()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Definition key.</span>
<span class="sd">        value : int, list, np.ndarray, str or tuple</span>
<span class="sd">            Definition value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;FOV&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Definition FOV uses values exceeding 1 m. &quot;</span>
                <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;New Pulseq interpreters expect values in units of meters.&quot;</span>
                <span class="n">warn</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Sequence.set_extension_string_ID">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.set_extension_string_ID">[docs]</a>
    <span class="k">def</span> <span class="nf">set_extension_string_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extension_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">extension_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set numeric ID for the given string extension ID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extension_str : str</span>
<span class="sd">            Given string extension ID.</span>
<span class="sd">        extension_id : int</span>
<span class="sd">            Given numeric extension ID.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If given numeric or string extension ID is not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">extension_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span>
            <span class="ow">or</span> <span class="n">extension_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numeric or string ID is not unique&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extension_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extension_str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_numeric_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extension_string_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequence.test_report">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.test_report">[docs]</a>
    <span class="k">def</span> <span class="nf">test_report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the sequence and return a text report.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ext_test_report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="Sequence.waveforms">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">append_RF</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompress the entire gradient waveform. Returns gradient waveforms as a tuple of `np.ndarray` of</span>
<span class="sd">        `gradient_axes` (typically 3) dimensions. Each `np.ndarray` contains timepoints and the corresponding</span>
<span class="sd">        gradient amplitude values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        append_RF : bool, default=False</span>
<span class="sd">            Boolean flag to indicate if RF wave shapes are to be appended after the gradients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wave_data : np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grad_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gx&quot;</span><span class="p">,</span> <span class="s2">&quot;gy&quot;</span><span class="p">,</span> <span class="s2">&quot;gz&quot;</span><span class="p">]</span>

        <span class="c1"># Collect shape pieces</span>
        <span class="k">if</span> <span class="n">append_RF</span><span class="p">:</span>
            <span class="n">shape_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad_channels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Last &#39;channel&#39; is RF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad_channels</span><span class="p">)</span>

        <span class="n">shape_pieces</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape_channels</span><span class="p">)]</span>
        <span class="n">out_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape_channels</span><span class="p">)</span>  <span class="c1"># Last &#39;channel&#39; is RF</span>

        <span class="n">curr_dur</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">time_range</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time range must be list of two elements&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End time of time_range must be after begin time&#39;</span><span class="p">)</span>
            
            <span class="c1"># Calculate end times of each block</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>
            <span class="c1"># Search block end times for start of time range</span>
            <span class="n">begin_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Search block begin times for end of time range</span>
            <span class="n">end_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">bd</span><span class="p">,</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">begin_block</span><span class="p">:</span><span class="n">end_block</span><span class="p">]</span>
            <span class="n">curr_dur</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">begin_block</span><span class="p">]</span>
            
        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grad_channels</span><span class="p">)):</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">grad_channels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">grad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Gradients</span>
                    <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;grad&quot;</span><span class="p">:</span>
                        <span class="c1"># Check if we have an extended trapezoid or an arbitrary gradient on a regular raster</span>
                        <span class="n">tt_rast</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">tt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span> <span class="o">+</span> <span class="mf">0.5</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tt_rast</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt_rast</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span>
                        <span class="p">):</span>  <span class="c1"># Arbitrary gradient</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            Arbitrary gradient: restore &amp; recompress shape - if we had a trapezoid converted to shape we</span>
<span class="sd">                            have to find the &quot;corners&quot; and we can eliminate internal samples on the straight segments</span>
<span class="sd">                            but first we have to restore samples on the edges of the gradient raster intervals for that</span>
<span class="sd">                            we need the first sample.</span>
<span class="sd">                            &quot;&quot;&quot;</span>
                            
                            <span class="c1"># TODO: Implement restoreAdditionalShapeSamples</span>
                            <span class="c1">#       https://github.com/pulseq/pulseq/blob/master/matlab/%2Bmr/restoreAdditionalShapeSamples.m</span>
                            
                            <span class="n">out_len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
                            <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">curr_dur</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">,</span> <span class="p">[</span><span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_raster_time</span><span class="o">/</span><span class="mi">2</span><span class="p">])),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">grad</span><span class="o">.</span><span class="n">first</span><span class="p">],</span> <span class="n">grad</span><span class="o">.</span><span class="n">waveform</span><span class="p">,</span> <span class="p">[</span><span class="n">grad</span><span class="o">.</span><span class="n">last</span><span class="p">]))</span>
                                <span class="p">]</span>
                            <span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Extended trapezoid</span>
                            <span class="n">out_len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">)</span>
                            <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">curr_dur</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">tt</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">waveform</span><span class="p">,</span>
                                <span class="p">]</span>
                            <span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">flat_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                            <span class="n">out_len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span>
                            <span class="n">_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                                <span class="p">(</span>
                                    <span class="n">cumsum</span><span class="p">(</span>
                                            <span class="n">curr_dur</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                                            <span class="n">grad</span><span class="o">.</span><span class="n">rise_time</span><span class="p">,</span>
                                            <span class="n">grad</span><span class="o">.</span><span class="n">flat_time</span><span class="p">,</span>
                                            <span class="n">grad</span><span class="o">.</span><span class="n">fall_time</span><span class="p">,</span>
                                    <span class="p">),</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_temp</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">rise_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">fall_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                                <span class="n">out_len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">3</span>
                                <span class="n">_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                                    <span class="p">(</span>
                                        <span class="n">cumsum</span><span class="p">(</span><span class="n">curr_dur</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">rise_time</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">fall_time</span><span class="p">),</span>
                                        <span class="n">grad</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_temp</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">amplitude</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: &quot;empty&quot; gradient with non-zero magnitude detected in block </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_counter</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># RF</span>
                <span class="n">rf</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span>
                <span class="k">if</span> <span class="n">append_RF</span><span class="p">:</span>
                    <span class="n">rf_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">curr_dur</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">,</span>
                            <span class="n">rf</span><span class="o">.</span><span class="n">signal</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                                <span class="mi">1</span><span class="n">j</span>
                                <span class="o">*</span> <span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
                            <span class="p">),</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">out_len</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">rf_piece</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">rf_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pre</span><span class="p">,</span> <span class="n">rf_piece</span><span class="p">))</span>
                        <span class="n">out_len</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rf</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">rf_piece</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">rf_raster_time</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">rf_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rf_piece</span><span class="p">,</span> <span class="n">post</span><span class="p">))</span>
                        <span class="n">out_len</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">post</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">shape_pieces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_piece</span><span class="p">)</span>

            <span class="n">curr_dur</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span><span class="n">block_counter</span><span class="p">]</span>

        <span class="c1"># Collect wave data</span>
        <span class="n">wave_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape_channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">wave_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
                <span class="k">continue</span>
            
            <span class="c1"># If the first element of the next shape has the same time as</span>
            <span class="c1"># the last element of the previous shape, drop the first</span>
            <span class="c1"># element of the next shape.</span>
            <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span>
                               <span class="p">[</span><span class="n">cur</span> <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">cur</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
                                <span class="k">for</span> <span class="n">prev</span><span class="p">,</span><span class="n">cur</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">:])])</span>

            <span class="n">wave_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">shape_pieces</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">rftdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wave_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rftdiff</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span>
                    <span class="s2">&quot;Time vector elements are not monotonically increasing.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">wave_data</span></div>



<div class="viewcode-block" id="Sequence.waveforms_and_times">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.waveforms_and_times">[docs]</a>
    <span class="k">def</span> <span class="nf">waveforms_and_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">append_RF</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompress the entire gradient waveform. Returns gradient waveforms as a tuple of `np.ndarray` of</span>
<span class="sd">        `gradient_axes` (typically 3) dimensions. Each `np.ndarray` contains timepoints and the corresponding</span>
<span class="sd">        gradient amplitude values. Additional return values are time points of excitations, refocusings and ADC</span>
<span class="sd">        sampling points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        append_RF : bool, default=False</span>
<span class="sd">            Boolean flag to indicate if RF wave shapes are to be appended after the gradients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wave_data : np.ndarray</span>
<span class="sd">        tfp_excitation : np.ndarray</span>
<span class="sd">            Contains time moments, frequency and phase offsets of the excitation RF pulses (similar for `</span>
<span class="sd">            tfp_refocusing`).</span>
<span class="sd">        tfp_refocusing : np.ndarray</span>
<span class="sd">        t_adc: np.ndarray</span>
<span class="sd">            Contains times of all ADC sample points.</span>
<span class="sd">        fp_adc : np.ndarray</span>
<span class="sd">            Contains frequency and phase offsets of each ADC object (not samples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">wave_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">(</span><span class="n">append_RF</span><span class="o">=</span><span class="n">append_RF</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>
        <span class="n">t_excitation</span><span class="p">,</span> <span class="n">fp_excitation</span><span class="p">,</span> <span class="n">t_refocusing</span><span class="p">,</span> <span class="n">fp_refocusing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rf_times</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>
        <span class="n">t_adc</span><span class="p">,</span> <span class="n">fp_adc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adc_times</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>
        
        <span class="c1"># Join times, frequency and phases of RF pulses for compatibility with previous implementation</span>
        <span class="n">tfp_excitation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_excitation</span><span class="p">)[</span><span class="kc">None</span><span class="p">],</span> <span class="n">fp_excitation</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tfp_refocusing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_refocusing</span><span class="p">)[</span><span class="kc">None</span><span class="p">],</span> <span class="n">fp_refocusing</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">wave_data</span><span class="p">,</span> <span class="n">tfp_excitation</span><span class="p">,</span> <span class="n">tfp_refocusing</span><span class="p">,</span> <span class="n">t_adc</span><span class="p">,</span> <span class="n">fp_adc</span></div>


<div class="viewcode-block" id="Sequence.waveforms_export">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.waveforms_export">[docs]</a>
    <span class="k">def</span> <span class="nf">waveforms_export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot `Sequence`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_range : iterable, default=(0, np.inf)</span>
<span class="sd">            Time range (x-axis limits) for all waveforms. Default is 0 to infinity (entire sequence).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        all_waveforms: dict</span>
<span class="sd">            Dictionary containing the following sequence waveforms and time array(s):</span>
<span class="sd">            - `t_adc` - ADC timing array [seconds]</span>
<span class="sd">            - `t_rf` - RF timing array [seconds]</span>
<span class="sd">            - `t_rf_centers`: `rf_t_centers`,</span>
<span class="sd">            - `t_gx`: x gradient timing array,</span>
<span class="sd">            - `t_gy`: y gradient timing array,</span>
<span class="sd">            - `t_gz`: z gradient timing array,</span>
<span class="sd">            - `adc` - ADC complex signal (amplitude=1, phase=adc phase) [a.u.]</span>
<span class="sd">            - `rf` - RF complex signal</span>
<span class="sd">            - `rf_centers`: RF centers array,</span>
<span class="sd">            - `gx` - x gradient</span>
<span class="sd">            - `gy` - y gradient</span>
<span class="sd">            - `gz` - z gradient</span>
<span class="sd">            - `grad_unit`: [kHz/m],</span>
<span class="sd">            - `rf_unit`: [Hz],</span>
<span class="sd">            - `time_unit`: [seconds],</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check time range validity</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">])</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time range&quot;</span><span class="p">)</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">adc_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">adc_signal_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">rf_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">rf_signal_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">rf_t_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">rf_signal_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">gx_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">gy_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">gz_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">gx_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">gy_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">gz_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">block_counter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_events</span><span class="p">:</span>  <span class="c1"># For each block</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_counter</span><span class="p">)</span>  <span class="c1"># Retrieve it</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Check if &quot;current time&quot; is within requested range.</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">:</span>
                <span class="c1"># Case 1: ADC</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">adc</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">adc</span>  <span class="c1"># Get adc info</span>
                    <span class="c1"># From Pulseq: According to the information from Klaus Scheffler and indirectly from Siemens this</span>
                    <span class="c1"># is the present convention - the samples are shifted by 0.5 dwell</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">delay</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">adc</span><span class="o">.</span><span class="n">num_samples</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">dwell</span>
                    <span class="n">adc_t</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">t</span>
                    <span class="n">adc_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">adc</span><span class="o">.</span><span class="n">freq_offset</span>
                    <span class="p">)</span>
                    <span class="n">adc_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">adc_t_all</span><span class="p">,</span> <span class="n">adc_t</span><span class="p">))</span>
                    <span class="n">adc_signal_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">adc_signal_all</span><span class="p">,</span> <span class="n">adc_signal</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rf</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">rf</span>
                    <span class="n">tc</span><span class="p">,</span> <span class="n">ic</span> <span class="o">=</span> <span class="n">calc_rf_center</span><span class="p">(</span><span class="n">rf</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span>
                    <span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="n">delay</span>

                    <span class="c1"># Debug - visualize</span>
                    <span class="c1"># sp12.plot(t_factor * (t0 + t), np.abs(rf.signal))</span>
                    <span class="c1"># sp13.plot(t_factor * (t0 + t), np.angle(rf.signal * np.exp(1j * rf.phase_offset)</span>
                    <span class="c1">#                                         * np.exp(1j * 2 * math.pi * rf.t * rf.freq_offset)),</span>
                    <span class="c1">#           t_factor * (t0 + tc), np.angle(rf.signal[ic] * np.exp(1j * rf.phase_offset)</span>
                    <span class="c1">#                                          * np.exp(1j * 2 * math.pi * rf.t[ic] * rf.freq_offset)),</span>
                    <span class="c1">#           &#39;xb&#39;)</span>

                    <span class="n">rf_t</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">t</span>
                    <span class="n">rf</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">rf</span><span class="o">.</span><span class="n">signal</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">phase_offset</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">t</span> <span class="o">*</span> <span class="n">rf</span><span class="o">.</span><span class="n">freq_offset</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">rf_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rf_t_all</span><span class="p">,</span> <span class="n">rf_t</span><span class="p">))</span>
                    <span class="n">rf_signal_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rf_signal_all</span><span class="p">,</span> <span class="n">rf</span><span class="p">))</span>
                    <span class="n">rf_t_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rf_t_centers</span><span class="p">,</span> <span class="p">[</span><span class="n">rf_t</span><span class="p">[</span><span class="n">ic</span><span class="p">]]))</span>
                    <span class="n">rf_signal_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rf_signal_centers</span><span class="p">,</span> <span class="p">[</span><span class="n">rf</span><span class="p">[</span><span class="n">ic</span><span class="p">]]))</span>

                <span class="n">grad_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gx&quot;</span><span class="p">,</span> <span class="s2">&quot;gy&quot;</span><span class="p">,</span> <span class="s2">&quot;gz&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">grad_channels</span><span class="p">)</span>
                <span class="p">):</span>  <span class="c1"># Check each gradient channel: x, y, and z</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">grad_channels</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># If this channel is on in current block</span>
                        <span class="n">grad</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">grad_channels</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;grad&quot;</span><span class="p">:</span>  <span class="c1"># Arbitrary gradient option</span>
                            <span class="c1"># In place unpacking of grad.t with the starred expression</span>
                            <span class="n">g_t</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">t0</span>
                                <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">delay</span>
                                <span class="o">+</span> <span class="p">[</span>
                                    <span class="mi">0</span><span class="p">,</span>
                                    <span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">g</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">grad</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">grad</span><span class="o">.</span><span class="n">waveform</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">last</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Trapezoid gradient option</span>
                            <span class="n">g_t</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span>
                                    <span class="n">t0</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">rise_time</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">flat_time</span><span class="p">,</span>
                                    <span class="n">grad</span><span class="o">.</span><span class="n">fall_time</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">g</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">grad</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                            <span class="n">gx_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gx_t_all</span><span class="p">,</span> <span class="n">g_t</span><span class="p">))</span>
                            <span class="n">gx_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gx_all</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">grad</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                            <span class="n">gy_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gy_t_all</span><span class="p">,</span> <span class="n">g_t</span><span class="p">))</span>
                            <span class="n">gy_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gy_all</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">grad</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                            <span class="n">gz_t_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gz_t_all</span><span class="p">,</span> <span class="n">g_t</span><span class="p">))</span>
                            <span class="n">gz_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gz_all</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>

            <span class="n">t0</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_durations</span><span class="p">[</span>
                <span class="n">block_counter</span>
            <span class="p">]</span>  <span class="c1"># &quot;Current time&quot; gets updated to end of block just examined</span>

        <span class="n">all_waveforms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;t_adc&quot;</span><span class="p">:</span> <span class="n">adc_t_all</span><span class="p">,</span>
            <span class="s2">&quot;t_rf&quot;</span><span class="p">:</span> <span class="n">rf_t_all</span><span class="p">,</span>
            <span class="s2">&quot;t_rf_centers&quot;</span><span class="p">:</span> <span class="n">rf_t_centers</span><span class="p">,</span>
            <span class="s2">&quot;t_gx&quot;</span><span class="p">:</span> <span class="n">gx_t_all</span><span class="p">,</span>
            <span class="s2">&quot;t_gy&quot;</span><span class="p">:</span> <span class="n">gy_t_all</span><span class="p">,</span>
            <span class="s2">&quot;t_gz&quot;</span><span class="p">:</span> <span class="n">gz_t_all</span><span class="p">,</span>
            <span class="s2">&quot;adc&quot;</span><span class="p">:</span> <span class="n">adc_signal_all</span><span class="p">,</span>
            <span class="s2">&quot;rf&quot;</span><span class="p">:</span> <span class="n">rf_signal_all</span><span class="p">,</span>
            <span class="s2">&quot;rf_centers&quot;</span><span class="p">:</span> <span class="n">rf_signal_centers</span><span class="p">,</span>
            <span class="s2">&quot;gx&quot;</span><span class="p">:</span> <span class="n">gx_all</span><span class="p">,</span>
            <span class="s2">&quot;gy&quot;</span><span class="p">:</span> <span class="n">gy_all</span><span class="p">,</span>
            <span class="s2">&quot;gz&quot;</span><span class="p">:</span> <span class="n">gz_all</span><span class="p">,</span>
            <span class="s2">&quot;grad_unit&quot;</span><span class="p">:</span> <span class="s2">&quot;[kHz/m]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;rf_unit&quot;</span><span class="p">:</span> <span class="s2">&quot;[Hz]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time_unit&quot;</span><span class="p">:</span> <span class="s2">&quot;[seconds]&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">all_waveforms</span></div>


<div class="viewcode-block" id="Sequence.write">
<a class="viewcode-back" href="../../../_autosummary/bmctool.utils.seq.write.Sequence.html#bmctool.utils.seq.write.Sequence.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">create_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">remove_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the sequence data to the given filename using the open file format for MR sequences.</span>

<span class="sd">        See also `pypulseq.Sequence.read_seq.read()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Filename of `.seq` file to be written to disk.</span>
<span class="sd">        create_signature : bool, default=True</span>
<span class="sd">            Boolean flag to indicate if the file has to be signed.</span>
<span class="sd">        remove_duplicates : bool, default=True</span>
<span class="sd">            Remove duplicate events from the sequence before writing</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signature or None : If create_signature is True, it returns the written .seq file&#39;s signature as a string, </span>
<span class="sd">        otherwise it returns None. Note that, if remove_duplicates is True, signature belongs to the </span>
<span class="sd">        deduplicated sequences signature, and not the Sequence that is stored in the Sequence object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">write_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">create_signature</span><span class="p">,</span> <span class="n">remove_duplicates</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signature_type</span> <span class="o">=</span> <span class="s2">&quot;md5&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signature_file</span> <span class="o">=</span> <span class="s2">&quot;text&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signature_value</span> <span class="o">=</span> <span class="n">signature</span>
            <span class="k">return</span> <span class="n">signature</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Patrick Schuenke.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>